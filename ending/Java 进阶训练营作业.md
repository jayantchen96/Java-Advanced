# Java 进阶训练营作业

## 1. JVM

​	Java是一门跨平台的语言，一次编译，各处运行。每次运行Java代码时需要先将其编译成字节码文件，然后运行在JVM上，JVM可以理解为Java代码运行的平台，理解JVM的运行机制可以帮助我们写出更加高效的代码。JVM主要包括内存模型、垃圾回收、内存分配和类加载器这几个部分。其中内存模型主要分为：堆、栈、方法区以及直接内存；垃圾回收主要是关于JVM如何进行垃圾回收的，有哪些算法，以及这些算法的优缺点；内存分配是关于JVM如何进行内存分配的，在创建一个对象时如何给他分配内存，能够保证尽可能少的进行垃圾回收；类加载器则是关于JVM如何加载一个类，包含哪几个过程，以及类加载器的种类等。除此之外，在实际应用中，我们会涉及到一些JVM性能调优的知识，如如何减少垃圾回收的次数和时间，如何防止堆栈溢出等，这些都是建立在对JVM的充分了解上的。



## 2. NIO

NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。

## 3. 并发编程

Java的多线程是较难的一块内容，涉及到多个线程并发地对内存变量进行修改时的安全问题。多线程开发的时候会有一些问题，比如安全性问题，一致性问题等，重排序问题，因为这些问题大家在写代码的时候会加锁。Java中应对多线程安全问题主要通过加锁的方式去解决，比如有悲观锁、乐观锁、自旋锁、轻量级锁、偏向锁等。还有响应的AQS组件去实现特定的一些功能小组件，如CountDownLatch、CyclicBarrier等。



## 4. Spring框架

Spring是一个开放源代码的设计层面框架，它是于2003 年兴起的一个轻量级的Java 开发框架。由Rod Johnson创建，其前身为Interface21框架，后改为了Spring并且正式发布。Spring是为了解决企业应用开发的复杂性而创建的。它解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。Spring 的理念：不去重新发明轮子。其核心是控制反转（IOC）和面向切面（AOP）。



## 5. MySQL

MySQL是一种关系型数据库，面向事务的。在我们编写业务代码的时候，都需要对数据进行读取、计算和存储，而根据目的的不同，可以将数据库分为面向业务的和面向分析的，其中MySQL就是一种面向事务的关系型数据库，它在3范式的基础上消除了主属性对于码的部分与传递函数依赖，主要存储的是一些状态信息，例如用户的id、性别、地域等。在实际的应用中，数据的读取和写入占代码运行时间的很大一部分，因此了解数据库的运行原理是十分必要的。MySQL数据库主要包括索引、查询优化、存储引擎、数据类型、切分、复制这么几个大的部分。SQL是一种关系数据库的管理语言，我们可以通过SQL来直接对关系型数据库进行管理，例如创建表、删除表、查询数据等操作。



## 6. 分库分表

随着业务系统的复杂度提升，数据量的增加，单机的计算能力和存储能力无法满足我们的需求，因此出现了分布式的概念，也就是为了解决数据量大到一台机器无法处理的时候，我们用多台机器来处理。其中数据库也由原来的存储到一台机器转变成存储到多台机器上，由一台机器转变成多台机器的过程中，需要我们将数据库上的数据拆分到多个机器上，也就是分库分表。分库的意思是将一个数据库，拆分成多个提供不同业务数据处理能力的数据库。分表则是当单表数据量过大，对单表进行拆分。根据拆分的方式不同，可以分为这么两种：水平拆分和垂直拆分。

## 7. RPC和微服务

RPC指的是远程服务调用，这是为了解决所要调用的接口方法不在本地而设计的，其目的也是让你觉得像是在本地调用函数一样简单。而微服务是SOA的进化版。 soa是在水平层上做划分，将前端、后端、测试模块、数据库分开来。微服务是在soa上还做了垂直层面上的划分，通过服务进行组件化。微服务是为了让系统解耦，因为随着系统规模越来越大，你更改某一模块涉及的别的模块可能也很多，所谓牵一发而动全身，而且系统中的不同模块开发可能由不同开发人员构成，大家开发的习惯甚至语言都有可能不一样，那么系统解耦就非常的重要，服务间互不影响，提高系统的开发效率和可用性等等。微服务是通过什么实现的？正是RPC。RPC可以说是用来做微服务的一种手段，我认为这两者是紧密相关的。

现在RPC框架有HSF、Dubbo等等，主要组件有服务消费方、服务提供方、服务地址注册中心和配置中心，可能有些还有监控中心吧，为了监控服务调用情况的。一般流程则是服务提供方暴露服务，将服务接口方法名、参数和相关ip地址注册到服务地址注册中心，服务消费方去服务地址注册中心查询服务地址，消费方再对该地址发起RPC调用。一般服务注册中心，可以用zookeeper来做。

## 8. 分布式缓存

分布式缓存一般使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。说到分布式缓存，就涉及到一致性hash算法了，该算法主要是将服务器和缓存都hash到一个环中，每次查询时，去找离缓存hash完映射位置最近的一个服务器（顺时针）即可。但是这种算法也有负载不均的问题。通过使用虚拟节点可以缓解这个问题。为什么有负载不均的问题？因为新加入的物理节点只影响了原来物理节点的一个，相当于只缓解了原来这个物理节点的缓存压力。所以在加入新的物理节点的时候，引入多个虚拟节点，以达到尽可能多的影响其他物理节点，但是影响又小。相当于影响范围大，影响力度小，平摊了。

这里主要讲讲用redis做分布式缓存的三个问题：

### 持久化

#### RDB持久化

对redis中的数据进行周期性持久化，是全量数据，适合做冷备份。数据恢复比AOF快。

#### AOF持久化

以追加的方式写入日志文件，没有磁盘寻址的开销。日志是每条写入命令。适合做热备份。

### 集群高可用

哨兵（sentinel），master，slave。

当slave下线的时候，等待重新加入集群，并使用增量复制同步数据。

当master下线的时候，需要从主观下线到客观下线状态来确认master下线，这个时候需要大家同意下线，num(sentinels)/2+1个投票，算大部分哨兵认为下线了。确认master客观下线之后，选出哨兵leader，由哨兵leader执行失效转移。至少3个哨兵，来保证集群高可用，不然2个哨兵有一个哨兵挂了，另一个哨兵收不到任何的投票，不会执行失效转移。宕机的master作为slave重新加上集群时，会重新清空数据。

**脑裂**指的是master由于网络原因与其他slave失去了连接，这时候又选出来一个新的master，相当于有两个master。

异步复制同步和脑裂都会造成数据丢失，只能通过拒绝写请求来减少数据丢失。

### 主从数据同步

#### 全量复制

当主节点将从节点加入slave中时，从节点保存了主节点的ip和host信息。从节点发现主节点的信息之后，会与主节点建立连接，并向主节点确认它可以处理请求。如果确认完毕，从节点通过psync命令请求数据同步，第一次连接一般都是全量复制，主节点生成RDB文件传给从节点。从节点清除自己的数据后载入接收的RDB文件，更新数据库。

之后主节点一般把写命令传给从节点，从节点依据这个写命令更新数据库状态。

#### 增量复制

看复制偏移量、复制积压缓冲区。主节点复制偏移量指的发送数据的字节数，从节点复制偏移量指的是接收数据的字节数。主节点向从节点发送写命令时，也会往缓冲区中备份一份。如果主从复制偏移量差的不多，是可以用增量复制的。复制缓冲区是输出缓冲区的一种，为每个从节点都分配一个，复制积压缓冲区却只有一个。

## 9. 分布式消息队列

消息队列一般用于应用间通信。消息模型主要分为两种，一种是点对点，一种是发布订阅，现在普遍采用发布订阅模式。消息队列的使用场景主要包括应用解耦、流量削峰和异步处理三种应用场景。应用解耦：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败。流量削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况。异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间。分布式消息队列的可靠性主要有发送端的可靠性、接受端的可靠性和消息队列的可靠性。发送端可通过在本地数据库创建消息表，将消息数据和业务数据一同保存在同一实例当中。利用本地数据库的事务机制，可以保证消息一定可以发送到消息队列中。接收端的可靠性可以通过保持幂等性（存进数据库等操作）来使得消费端能够从消息队列中成功消费一次消息。消息队列保证可靠性的方式则是给每个队列都创建多个副本，当消息写入一定量的副本中时，消息才能算写成功，这样保证消息的可用性，也就是保证不会丢消息。

一般分布式消息队列基本组成差不多，像RocketMQ则是由nameserver、block集群、producer、consumer这几个部分组成。一台blocker机器上会有多个queue，这就和kafka里面一台服务器上有多个topic，每个topic里面有好几个partition一样，这个queue和partition是同等的概念。
